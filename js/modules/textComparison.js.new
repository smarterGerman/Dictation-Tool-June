/**
 * Module for comparing transcribed text with reference text
 * Includes German special character transformations and real-time error highlighting
 */

/**
 * Transform input text to normalize German special characters
 * @param {string} input - The user input text
 * @returns {string} - Normalized text with transformed special characters
 */
export function transformSpecialCharacters(input) {
    if (!input) return '';
    
    try {
        // Try-catch to handle any unexpected errors in the transformation process
        let result = input;
        
        // Apply transformations in a specific order for best results
        // 1. First transform letter+e patterns
        try {
            result = transformLetterE(result);
        } catch (letterEError) {
            try { console.error("Letter+e transformation error:", letterEError); } catch (e) { /* Silence console errors */ }
        }
        
        // 2. Then transform colon patterns
        try {
            result = transformColon(result);
        } catch (colonError) {
            try { console.error("Colon transformation error:", colonError); } catch (e) { /* Silence console errors */ }
        }
        
        // 3. Then transform slash patterns
        try {
            result = transformSlash(result);
        } catch (slashError) {
            try { console.error("Slash transformation error:", slashError); } catch (e) { /* Silence console errors */ }
        }
        
        // 4. Finally transform eszett
        try {
            result = transformEszett(result);
        } catch (eszettError) {
            try { console.error("Eszett transformation error:", eszettError); } catch (e) { /* Silence console errors */ }
        }
        
        // Safer logging without stringification that might cause issues in some browsers
        if (result !== input && typeof console !== 'undefined') {
            try {
                console.log("Transformation applied:", input, "→", result);
            } catch (logError) {
                // Silently fail if logging causes issues
            }
        }
        
        return result;
    } catch (err) {
        // Fallback in case of any error - return original input
        try { console.error("Error in transformation:", err); } catch (e) { /* Silence console errors */ }
        return input;
    }
}

/**
 * Transform letter+e notation to umlauts (ae → ä, oe → ö, ue → ü)
 * @param {string} text - Input text
 * @returns {string} - Transformed text
 */
function transformLetterE(text) {
    try {
        // Use a more reliable method with simple single replacements
        let result = text;
        result = result.replace(/ae/g, 'ä');
        result = result.replace(/oe/g, 'ö');
        result = result.replace(/ue/g, 'ü');
        result = result.replace(/Ae/g, 'Ä');
        result = result.replace(/Oe/g, 'Ö');
        result = result.replace(/Ue/g, 'Ü');
        return result;
    } catch (error) {
        try { console.error("Error in transformLetterE:", error); } catch (e) { /* Silence console errors */ }
        return text; // Return original text if transformation fails
    }
}

/**
 * Transform colon notation to umlauts (a: → ä, o: → ö, u: → ü)
 * @param {string} text - Input text
 * @returns {string} - Transformed text
 */
function transformColon(text) {
    try {
        let result = text;
        result = result.replace(/a:/g, 'ä');
        result = result.replace(/o:/g, 'ö');
        result = result.replace(/u:/g, 'ü');
        result = result.replace(/A:/g, 'Ä');
        result = result.replace(/O:/g, 'Ö');
        result = result.replace(/U:/g, 'Ü');
        return result;
    } catch (error) {
        try { console.error("Error in transformColon:", error); } catch (e) { /* Silence console errors */ }
        return text; // Return original text if transformation fails
    }
}

/**
 * Transform slash notation to umlauts (a/ → ä, o/ → ö, u/ → ü)
 * @param {string} text - Input text
 * @returns {string} - Transformed text
 */
function transformSlash(text) {
    try {
        let result = text;
        result = result.replace(/a\//g, 'ä');
        result = result.replace(/o\//g, 'ö');
        result = result.replace(/u\//g, 'ü');
        result = result.replace(/A\//g, 'Ä');
        result = result.replace(/O\//g, 'Ö');
        result = result.replace(/U\//g, 'Ü');
        return result;
    } catch (error) {
        try { console.error("Error in transformSlash:", error); } catch (e) { /* Silence console errors */ }
        return text; // Return original text if transformation fails
    }
}

/**
 * Transform eszett alternative writings to proper eszett (ß)
 * @param {string} text - The input text
 * @returns {string} - Text with transformed eszett
 */
function transformEszett(text) {
    try {
        // Replace "ss" with "ß"
        return text.replace(/ss/g, 'ß');
    } catch (error) {
        try { console.error("Error in transformEszett:", error); } catch (e) { /* Silence console errors */ }
        return text; // Return original text if transformation fails
    }
}

/**
 * Compare user input with reference text
 * @param {string} userInput - The user's transcribed text
 * @param {string} referenceText - The correct reference text
 * @returns {Object} - Comparison results with match status
 */
export function compareTexts(userInput, referenceText) {
    try {
        if (!userInput || !referenceText) {
            return { 
                isMatch: false,
                transformedInput: '',
                errorPositions: []
            };
        }
        
        // Transform special characters in user input
        let transformedInput = userInput;
        try {
            transformedInput = transformSpecialCharacters(userInput);
        } catch (transformError) {
            try { console.error("Error transforming text for comparison:", transformError); } catch (e) { /* Silence console errors */ }
        }
        
        // Normalize both texts for comparison 
        // (trim whitespace but preserve case for better error highlighting)
        const normalizedInput = transformedInput.trim();
        const normalizedReference = referenceText.trim();
        
        // For exact match check, use case-insensitive comparison
        const isExactMatch = normalizedInput.toLowerCase() === normalizedReference.toLowerCase();
        
        // Calculate a similarity score (for partial matching if needed)
        let similarityScore = 0;
        try {
            similarityScore = calculateSimilarity(
                normalizedInput.toLowerCase(), 
                normalizedReference.toLowerCase()
            );
        } catch (similarityError) {
            try { console.error("Error calculating similarity:", similarityError); } catch (e) { /* Silence console errors */ }
        }
        
        // Find error positions for highlighting (case-sensitive for better feedback)
        const errorPositions = [];
        
        if (!isExactMatch) {
            try {
                // Use Levenshtein distance to find a better alignment of the texts
                const alignment = alignTexts(normalizedInput, normalizedReference);
                
                // Mark positions with errors
                alignment.forEach((position, index) => {
                    if (position.status === 'error' || position.status === 'missing') {
                        errorPositions.push(index);
                    }
                });
            } catch (alignmentError) {
                try { console.error("Error aligning texts:", alignmentError); } catch (e) { /* Silence console errors */ }
            }
        }
        
        return {
            isMatch: isExactMatch,
            transformedInput: normalizedInput,
            similarityScore,
            errorPositions
        };
    } catch (error) {
        try { console.error("Error in compareTexts:", error); } catch (e) { /* Silence console errors */ }
        return {
            isMatch: false,
            transformedInput: userInput || '',
            similarityScore: 0,
            errorPositions: []
        };
    }
}

/**
 * Calculate similarity between two strings (0-100%)
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} - Similarity percentage
 */
function calculateSimilarity(str1, str2) {
    try {
        if (!str1 && !str2) return 100; // Both empty = perfect match
        if (!str1 || !str2) return 0;   // One empty = no match
        
        // Use Levenshtein distance to calculate similarity
        const distance = levenshteinDistance(str1, str2);
        const maxLength = Math.max(str1.length, str2.length);
        
        // Convert to similarity percentage
        return Math.round(((maxLength - distance) / maxLength) * 100);
    } catch (error) {
        try { console.error("Error calculating similarity:", error); } catch (e) { /* Silence console errors */ }
        return 0; // Default to no similarity on error
    }
}

/**
 * Calculate Levenshtein distance between two strings
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} - Levenshtein distance
 */
function levenshteinDistance(str1, str2) {
    try {
        const m = str1.length;
        const n = str2.length;
        
        // Create a matrix of size (m+1) x (n+1)
        const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
        
        // Initialize first row and column
        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;
        
        // Fill the matrix
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,      // deletion
                    dp[i][j - 1] + 1,      // insertion
                    dp[i - 1][j - 1] + cost // substitution
                );
            }
        }
        
        return dp[m][n];
    } catch (error) {
        try { console.error("Error in levenshteinDistance:", error); } catch (e) { /* Silence console errors */ }
        return Math.max(str1.length, str2.length); // Worst case distance on error
    }
}

/**
 * Align two texts to find errors
 * @param {string} input - User input
 * @param {string} reference - Reference text
 * @returns {Array} - Array of position objects with status
 */
function alignTexts(input, reference) {
    try {
        // Initialize result array
        const result = [];
        
        // If either string is empty, mark all positions as errors
        if (!input) {
            return reference.split('').map(() => ({ status: 'missing' }));
        }
        
        if (!reference) {
            return input.split('').map(() => ({ status: 'error' }));
        }
        
        // Simple direct character comparison with case-insensitive matching
        // but preserving case information for display
        const inputChars = input.split('');
        const refChars = reference.split('');
        
        // Compare each character
        const minLength = Math.min(inputChars.length, refChars.length);
        
        // Process characters that exist in both strings
        for (let i = 0; i < minLength; i++) {
            const inputChar = inputChars[i];
            const refChar = refChars[i];
            
            // Case-insensitive comparison
            if (inputChar.toLowerCase() === refChar.toLowerCase()) {
                result.push({ 
                    status: 'match', 
                    inputChar, 
                    refChar 
                });
            } else {
                result.push({ 
                    status: 'error', 
                    inputChar, 
                    refChar 
                });
            }
        }
        
        // Mark any extra characters in input as errors
        if (inputChars.length > refChars.length) {
            for (let i = minLength; i < inputChars.length; i++) {
                result.push({ 
                    status: 'error', 
                    inputChar: inputChars[i],
                    refChar: null
                });
            }
        }
        
        // Mark any missing characters from reference as missing
        if (refChars.length > inputChars.length) {
            for (let i = minLength; i < refChars.length; i++) {
                result.push({ 
                    status: 'missing',
                    inputChar: null,
                    refChar: refChars[i]
                });
            }
        }
        
        return result;
    } catch (error) {
        try { console.error("Error in alignTexts:", error); } catch (e) { /* Silence console errors */ }
        
        // Return a simple fallback on error
        if (input) {
            return input.split('').map(char => ({ 
                status: 'error', 
                inputChar: char,
                refChar: null
            }));
        }
        return [];
    }
}

/**
 * Generate HTML with highlighted error positions
 * @param {string} text - The text to highlight
 * @param {Array} errorPositions - Array of error positions
 * @returns {string} - HTML with highlighted errors
 */
export function generateHighlightedHTML(text, errorPositions) {
    try {
        if (!text) return '';
        
        const errorSet = new Set(errorPositions);
        const chars = text.split('');
        let html = '';
        
        let inErrorSpan = false;
        
        chars.forEach((char, index) => {
            const isError = errorSet.has(index);
            
            // Start error span if needed
            if (isError && !inErrorSpan) {
                html += '<span class="error">';
                inErrorSpan = true;
            } 
            // End error span if needed
            else if (!isError && inErrorSpan) {
                html += '</span>';
                inErrorSpan = false;
            }
            
            // Add character (replacing spaces with nbsp for visibility)
            html += char === ' ' ? '&nbsp;' : escapeHTML(char);
        });
        
        // Close any open error span
        if (inErrorSpan) {
            html += '</span>';
        }
        
        return html;
    } catch (error) {
        try { console.error("Error generating highlighted HTML:", error); } catch (e) { /* Silence console errors */ }
        return escapeHTML(text); // Return plain escaped text on error
    }
}

/**
 * Escape HTML special characters
 * @param {string} text - Text to escape
 * @returns {string} - Escaped text
 */
function escapeHTML(text) {
    try {
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    } catch (error) {
        try { console.error("Error escaping HTML:", error); } catch (e) { /* Silence console errors */ }
        return text;
    }
}
